import subprocess
import os
import glob
from argparse import ArgumentError

from riscv_assembler.convert import AssemblyConverter

def parse_conf_by_key(conf: str, key: str):
    with open(conf, 'r') as f:
        for line in f:
            line = line.strip()

            if line.startswith(key):
                key, value = line.split('=', 1)
                res = value.strip().strip('"').strip("'")
                break

    if not res:
        raise Exception(f"Error: Required component entry: {key} is not found in {conf}")

    return res

def get_conf_dir(key: str, conf='test.cfg'):
    dir = parse_conf_by_key(conf, key)
    dir = os.path.expanduser(dir)
    dir = os.path.abspath(dir)

    # Check if the directory exists
    if not os.path.isdir(dir):
        raise Exception(f"Error: Directory {dir} does not exist")

    return dir


def get_filelist_with_pattern(pat: str, src_dir, conf='test.cfg'):
    # Construct the search pattern
    pattern = os.path.join(src_dir, pat)

    # Find all files matching the pattern
    file_list = glob.glob(pattern)

    # Return the list of full file paths
    return file_list


def run_filecheck(filecheck_src, llvm_bin):
    # Define the paths to the executables
    llvm_mc_path = os.path.join(llvm_bin, 'llvm-mc')
    file_check_path = os.path.join(llvm_bin, 'FileCheck')

    # Ensure that the executables exist
    if not os.path.isfile(llvm_mc_path):
        raise Exception(f"Error: llvm-mc not found at {llvm_mc_path}")

    if not os.path.isfile(file_check_path):
        raise Exception(f"Error: FileCheck not found at {file_check_path}")

    # Construct the command arguments
    llvm_mc_cmd = [llvm_mc_path, filecheck_src, "-triple=riscv32", "-show-encoding"]
    file_check_cmd = [file_check_path, "-check-prefixes=CHECK-ASM", filecheck_src]

    try:
        # Start the llvm-mc process
        llvm_mc_process = subprocess.Popen(
            llvm_mc_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Start the FileCheck process, reading from llvm-mc's stdout
        file_check_process = subprocess.Popen(
            file_check_cmd,
            stdin=llvm_mc_process.stdout,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Close llvm_mc_process's stdout in the parent to allow llvm_mc_process to receive a SIGPIPE if file_check_process exits
        llvm_mc_process.stdout.close()

        # Communicate with file_check_process to get its output and errors
        file_check_stdout, file_check_stderr = file_check_process.communicate()

        # Wait for llvm_mc_process to finish and get stderr
        llvm_mc_stderr = llvm_mc_process.stderr.read()
        llvm_mc_process.stderr.close()
        llvm_mc_process.wait()

        # Check for errors in llvm-mc process
        if llvm_mc_process.returncode != 0:
            print(f"Error: llvm-mc exited with return code {llvm_mc_process.returncode}")
            print("llvm-mc stderr:")
            print(llvm_mc_stderr.decode())
            return

        # Check for errors in FileCheck process
        if file_check_process.returncode != 0:
            print(f"Error: FileCheck exited with return code {file_check_process.returncode}")
            print("FileCheck stderr:")
            print(file_check_stderr.decode())
            return

        # If both processes succeeded, print the output
        print(f"Filecheck on {os.path.basename(filecheck_src)} succeed!")

    except Exception as e:
        print(f"Starting llvm toolchain failed: {e}")


def generate_valid_s(input_file, output_file=""):
    """
    Reads an assembly file, obtains the machine code encoding for each instruction,
    and writes an output file where each instruction is preceded by a
    '# CHECK-ASM: encoding: [...]' comment line.

    If output_file is an empty string, the output file name is generated by
    appending '-valid' before the file extension of input_file.

    Parameters:
    - input_file: Path to the input assembly file (e.g., './MC/arith.s')
    - output_file: Path to the output file to write. If empty, generated automatically.
    """

    # Determine the output file name if not provided
    if not output_file:
        # Split the input file into directory, base name, and extension
        dir_name, base_name = os.path.split(input_file)
        file_name, ext = os.path.splitext(base_name)
        # Check if the file name already ends with '-valid'
        if file_name.endswith('-valid'):
            # Use the input file name as the output file name (overwrite)
            new_base_name = base_name  # file_name + ext
        else:
            # Append '-valid' before the extension
            new_base_name = f"{file_name}-valid{ext}"
        # Construct the output file path
        output_file = os.path.join(dir_name, new_base_name)

    cnv = AssemblyConverter(hex_mode=True, output_mode='a')  # Initialize converter
    encodings = cnv.convert(input_file)  # Get encodings

    with open(input_file, 'r') as f_in, open(output_file, 'w') as f_out:
        # Write initial comments
        f_out.write('# FileCheck compatible validation tests\n')
        f_out.write('#  llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \\\n')
        f_out.write('# | FileCheck -check-prefixes=CHECK-ASM %s\n\n\n')

        instructions = f_in.readlines()
        encoding_index = 0

        for line in instructions:
            stripped_line = line.strip()
            if not stripped_line or stripped_line.startswith('#'):
                f_out.write(line)
                continue
            else:
                encoding = encodings[encoding_index]
                encoding_index += 1

                # Convert the encoding string to an integer
                encoding_int = int(encoding, 16)

                # Convert the integer to bytes in little-endian order
                encoding_bytes = encoding_int.to_bytes(4, byteorder='little')

                # Format bytes as hex strings
                encoding_hex = ','.join(f'0x{byte:02x}' for byte in encoding_bytes)

                # Write the CHECK-ASM line
                f_out.write(f'# CHECK-ASM: encoding: [{encoding_hex}]\n')
                # Write the instruction line
                f_out.write(line)



if __name__ == "__main__":
    # step.1  generate valid check-files from rv32i assembler
    asm_dir = get_conf_dir(key='ASM_DIR')
    asm_files = get_filelist_with_pattern(pat='*.s', src_dir=asm_dir)
    for af in asm_files:
        generate_valid_s(input_file=af)

    # step.2 Parse test.cfg
    llvm_bin = get_conf_dir(key='LLVM_BIN')
    # fc_dir = get_conf_dir(key='FILECHECK_SRC_DIR')
    fc_list = get_filelist_with_pattern(pat='*-valid.s', src_dir=asm_dir)

    # step.3 run llvm Filecheck
    for fc in fc_list:
        run_filecheck(fc, llvm_bin)
